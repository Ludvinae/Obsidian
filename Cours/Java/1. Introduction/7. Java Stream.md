# <span style="color:darkorange;">Partie 7 : Comprendre Java Streams</span> üìò

En Java, les _Streams_ fournissent une API puissante pour manipuler les collections de donn√©es de mani√®re fonctionnelle. Ils permettent de formuler des op√©rations de filtrage, de transformation, et d'agr√©gation de mani√®re concise.

### Exemple initial :

```java
List<Integer> scores = Arrays.asList(90, 71, 82, 93, 75, 82);
List<Integer> scoresFiltres = scores.stream()
                                    .filter(score -> score > 80)
                                    .collect(Collectors.toList());
```

üîç **Note :** Ce code filtre une liste d'entiers pour obtenir uniquement les scores sup√©rieurs √† 80.

---

## <span style="color:darkorange;">Java Streams et Expressions Lambda</span> üêë

Les expressions lambda en Java fournissent une syntaxe concise pour √©crire des fonctions anonymes, permettant ainsi d'effectuer des op√©rations complexes sur les collections.

### Exemple avec `filter()` et `map()` :

```java
List<Double> scoresEleves = scores.stream()
                                  .filter(score -> score > 80)
                                  .map(score -> score * 1.1)
                                  .collect(Collectors.toList());
```

üîç **Explication :** `filter(score -> score > 80)` filtre les scores sup√©rieurs √† 80. `map(score -> score * 1.1)` augmente chaque score filtr√© de 10 %.

### Exemple avec `sorted()` et `comparingInt()` :

```java
List<Integer> scoresTries = scores.stream()
                                  .sorted(Comparator.comparingInt(score -> score))
                                  .collect(Collectors.toList());
```

üîç **Analyse :** Trie les scores en ordre croissant avec `sorted()` et `comparingInt(score -> score)`.

---

## <span style="color:darkorange;">Manipulation de Collections avec Java Streams</span> üõ†Ô∏è

Les Streams offrent des m√©thodes pour filtrer, trier, agr√©ger, et transformer les collections de mani√®re √©l√©gante et fonctionnelle.

### Exemple avec `max()` et `average()` :

```java
OptionalInt scoreMax = scores.stream()
                             .mapToInt(Integer::intValue)
                             .max();
OptionalDouble scoreMoyen = scores.stream()
                                  .mapToInt(Integer::intValue)
                                  .average();
```

üîç **Contexte :** `max()` trouve le score le plus √©lev√©, tandis que `average()` calcule le score moyen de la collection.

### Exemple avec `groupingBy()` :

```java
Map<Integer, Long> groupesScores = scores.stream()
                                         .collect(Collectors.groupingBy(score -> score / 10, Collectors.counting()));
groupesScores.forEach((k, v) -> System.out.println("Scores " + (k * 10) + "s : " + v));
```

üîç **D√©tail :** `groupingBy(score -> score / 10, counting())` regroupe les scores par dizaines.

---

## <span style="color:darkorange;">Plus de Java Streams : Jointures et Plus</span> üîó

Bien que Java n'ait pas de m√©thode int√©gr√©e pour les jointures comme LINQ, des m√©thodes telles que `zip()` peuvent √™tre simul√©es via l'API des Streams.

### Exemple de jointure :

```java
List<String> etudiants = Arrays.asList("Alice", "Bob", "Claire");
List<Integer> notesEtudiants = Arrays.asList(85, 88, 91);

List<String> resultat = IntStream.range(0, Math.min(etudiants.size(), notesEtudiants.size()))
                                 .mapToObj(i -> etudiants.get(i) + " a " + notesEtudiants.get(i))
                                 .collect(Collectors.toList());

resultat.forEach(System.out::println);
```

üîç **Explication :** `IntStream.range(0, min(...))` parcourt les deux listes simultan√©ment, cr√©ant des cha√Ænes descriptives pour chaque paire.

---

### <span style="color:red;">Exercice 1: Filtrage avec Java Streams</span> üß©

1. Utilisez les Streams pour filtrer les scores de la liste `scores` afin d'obtenir uniquement ceux qui sont sup√©rieurs √† 80.
2. Affichez les scores filtr√©s.

### Correction:

```java
List<Integer> scoresFiltres = scores.stream()
                                    .filter(score -> score > 80)
                                    .collect(Collectors.toList());

scoresFiltres.forEach(System.out::println);
```

### <span style="color:red;">Exercice 2: Transformation avec Java Streams</span> üß©

1. Utilisez les Streams pour transformer chaque score de la liste `scores` en le multipliant par 1.1.
2. Affichez les scores transform√©s.

### Correction:

```java
List<Double> scoresTransformes = scores.stream()
                                       .map(score -> score * 1.1)
                                       .collect(Collectors.toList());

scoresTransformes.forEach(System.out::println);
```

### <span style="color:red;">Exercice 3: Agr√©gation avec Java Streams</span> üß©

1. Utilisez les Streams pour trouver le score maximum et le score moyen dans la liste `scores`.
2. Affichez ces valeurs.

### Correction:

```java
OptionalInt scoreMax = scores.stream()
                             .mapToInt(Integer::intValue)
                             .max();
OptionalDouble scoreMoyen = scores.stream()
                                  .mapToInt(Integer::intValue)
                                  .average();

scoreMax.ifPresent(max -> System.out.println("Score maximum: " + max));
scoreMoyen.ifPresent(moyen -> System.out.println("Score moyen: " + moyen));
```

### <span style="color:red;">Cata 1: Filtre et Projection</span> üß©

#### Description

Supposons que vous ayez une liste de noms et que vous vouliez filtrer les noms qui commencent par la lettre "A" et afficher uniquement les trois premiers noms restants en majuscules.

#### Donn√©es d'entr√©e

```java
List<String> noms = Arrays.asList("Alice", "Bob", "Anna", "Alex", "David", "Andrew");
```

#### T√¢ches √† effectuer

1. Utilisez les Streams pour filtrer les noms qui commencent par la lettre "A".
2. S√©lectionnez les trois premiers noms restants.
3. Convertissez ces noms en majuscules.
4. Affichez les noms r√©sultants.

### **Correction**

```java
List<String> nomsFiltres = noms.stream()
                               .filter(nom -> nom.startsWith("A"))
                               .limit(3)
                               .map(String::toUpperCase)
                               .collect(Collectors.toList());

nomsFiltres.forEach(System.out::println);
```

### <span style="color:red;">Cata 2: Jointure de Donn√©es</span> üß©

#### Description

Vous avez deux listes : une contenant des noms d'√©tudiants et l'autre contenant leurs notes respectives. Vous devez les fusionner en une seule liste contenant les noms des √©tudiants ayant obtenu une note sup√©rieure √† 80.

#### Donn√©es d'entr√©e

```java
List<String> etudiants = Arrays.asList("Alice", "Bob", "Claire", "David");
List<Integer> notes = Arrays.asList(85, 70, 90, 65);
```

#### T√¢ches √† effectuer

1. Associez chaque √©tudiant √† sa note correspondante.
2. Filtrez les √©tudiants ayant obtenu une note sup√©rieure √† 80.
3. Affichez les noms des √©tudiants restants.

### **Correction**

```java
List<String> etudiantsAdmis = IntStream.range(0, Math.min(etudiants.size(), notes.size()))
                                       .mapToObj(i -> new AbstractMap.SimpleEntry<>(etudiants.get(i), notes.get(i)))
                                       .filter(entry -> entry.getValue() > 80)
                                       .map(Map.Entry::getKey)
                                       .collect(Collectors.toList());

etudiantsAdmis.forEach(System.out::println);
```

### <span style="color:red;">Cata 3: Agr√©gation de Donn√©es</span> üß©

#### Description

Vous avez une liste de prix des produits dans un magasin. Trouvez le prix moyen des produits dont le prix est sup√©rieur √† 50.

#### Donn√©es d'entr√©e

```java
List<Double> prixProduits = Arrays.asList(45.5, 78.9, 60.0, 30.5, 55.2, 40.0);
```

#### T√¢ches √† effectuer

1. Filtrez les prix des produits sup√©rieurs √† 50.
2. Calculez la moyenne des prix restants.

### Correction

```java
OptionalDouble prixMoyen = prixProduits.stream()
                                       .filter(prix -> prix > 50)
                                       .mapToDouble(Double::doubleValue)
                                       .average();

prixMoyen.ifPresent(moyen -> System.out.println("Le prix moyen des produits sup√©rieurs √† 50 est : " + moyen));
```

