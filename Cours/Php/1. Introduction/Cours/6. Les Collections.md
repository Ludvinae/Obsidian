# <span style="color:magenta;">Introduction aux Collections en PHP</span> ğŸ—ƒï¸

Les **collections** regroupent des structures de donnÃ©es et des outils permettant de **stocker**, **organiser** et **manipuler** des ensembles dâ€™Ã©lÃ©ments de maniÃ¨re expressive et sÃ»re.  
En PHP, au-delÃ  des **tableaux** (abordÃ©s au cours prÃ©cÃ©dent), on dispose dâ€™un arsenal trÃ¨s utile : la **SPL** (*Standard PHP Library*) avec ses **structures spÃ©cialisÃ©es** (listes, piles, files, files de prioritÃ©, tas, etc.), des **objets tableaux** (`ArrayObject`), ainsi que la possibilitÃ© de crÃ©er **vos propres collections typÃ©es** via `IteratorAggregate`, `Countable`, `ArrayAccess`, etc.

Ce cours prÃ©sente les **collections natives** (SPL) et montre comment construire une **collection sur mesure** propre et testable.

---

## <span style="color:magenta;">Panorama rapide</span> ğŸ§­

- **Tableaux PHP** : polyvalents, indexÃ©s/associatifs, base de 90% des manipulations.  
- **SPL â€“ Structures spÃ©cialisÃ©es** :
  - `SplDoublyLinkedList` (liste doublement chaÃ®nÃ©e)
  - `SplStack` (pile LIFO)
  - `SplQueue` (file FIFO)
  - `SplPriorityQueue` (file avec prioritÃ©s)
  - `SplHeap`, `SplMaxHeap`, `SplMinHeap` (tas / heaps)
  - `SplFixedArray` (tableau Ã  taille fixe, mÃ©moire optimisÃ©e)
  - `SplObjectStorage` (ensemble dâ€™objets â€“ *set* dâ€™objets)
- **Collections â€œobjetâ€ sur mesure** :
  - `ArrayObject` (un tableauâ€¦ en objet)
  - Collections typÃ©es via `IteratorAggregate` + `Countable` (pattern recommandÃ©)

---

## <span style="color:magenta;">SPL : Listes, Piles, Files</span> ğŸ§±

### `SplDoublyLinkedList` â€“ Liste doublement chaÃ®nÃ©e ğŸ”—
Insertion/suppression **en tÃªte/en queue** en O(1), itÃ©ration flexible.

```php
<?php
$list = new SplDoublyLinkedList();
$list->setIteratorMode(SplDoublyLinkedList::IT_MODE_KEEP); // conserve les Ã©lÃ©ments lors de l'itÃ©ration
$list->push("Alice");  // fin
$list->unshift("Bob"); // dÃ©but

foreach ($list as $item) {
    echo $item . PHP_EOL; // Bob, Alice
}
```

### `SplStack` â€“ Pile (LIFO) ğŸ“š
Dernier entrÃ©, premier sorti.

```php
<?php
$stack = new SplStack();
$stack->push("A");
$stack->push("B");
echo $stack->pop(); // B
echo $stack->pop(); // A
```

### `SplQueue` â€“ File (FIFO) ğŸš¶
Premier entrÃ©, premier sorti.

```php
<?php
$q = new SplQueue();
$q->enqueue("TÃ¢che1");
$q->enqueue("TÃ¢che2");
echo $q->dequeue(); // TÃ¢che1
echo $q->dequeue(); // TÃ¢che2
```

---

## <span style="color:magenta;">PrioritÃ©s et Tas (Heaps)</span> ğŸ¥‡

### `SplPriorityQueue` â€“ File Ã  prioritÃ©
Chaque Ã©lÃ©ment a une **prioritÃ©**. Attention : selon le mode, lâ€™itÃ©ration peut **extraire** les Ã©lÃ©ments.

```php
<?php
$pq = new SplPriorityQueue();
$pq->setExtractFlags(SplPriorityQueue::EXTR_DATA); // ne renvoyer que la donnÃ©e
$pq->insert("Urgent", 100);
$pq->insert("Normal", 10);
$pq->insert("Faible", 1);

while (!$pq->isEmpty()) {
    echo $pq->extract() . PHP_EOL; // Urgent, Normal, Faible
}
```

### `SplMaxHeap` / `SplMinHeap` â€“ Tas max/min
Structure binaire optimisÃ©e pour rÃ©cupÃ©rer **max**/**min** en O(1), insertion/suppression en O(log n).

```php
<?php
$maxHeap = new SplMaxHeap();
foreach ([3, 10, 6, 1] as $n) $maxHeap->insert($n);

echo $maxHeap->extract() . PHP_EOL; // 10
echo $maxHeap->extract() . PHP_EOL; // 6
```

---

## <span style="color:magenta;">Tableaux spÃ©cialisÃ©s</span> ğŸ§°

### `SplFixedArray` â€“ Tableau Ã  taille fixe
Moins de surcoÃ»t mÃ©moire que les tableaux dynamiques.

```php
<?php
$fa = new SplFixedArray(3);
$fa[0] = "A";
$fa[1] = "B";
$fa[2] = "C";
// $fa[3] = "D"; // âš ï¸ Erreur : hors limites
foreach ($fa as $v) { echo $v . PHP_EOL; }
```

### `SplObjectStorage` â€“ Ensemble dâ€™objets (Set) ğŸ§‘â€ğŸ¤â€ğŸ§‘
Stocke **des objets uniques**. Permet dâ€™associer des **mÃ©tadonnÃ©es** Ã  chaque objet.

```php
<?php
class User { public function __construct(public string $name) {} }

$u1 = new User("Alice");
$u2 = new User("Bob");

$store = new SplObjectStorage();
$store->attach($u1, ["role" => "admin"]);
$store->attach($u2, ["role" => "editor"]);

foreach ($store as $obj) {
    $meta = $store[$obj]; // mÃ©tadonnÃ©es
    echo $obj->name . " (" . $meta["role"] . ")" . PHP_EOL;
}
```

---

## <span style="color:magenta;">ArrayObject & ItÃ©rateurs</span> ğŸ§¾

### `ArrayObject` â€“ Un tableau â€œobjetâ€
Tri, Ã©change, itÃ©ration via `IteratorAggregate`.

```php
<?php
$ao = new ArrayObject(["c" => 3, "a" => 1, "b" => 2]);

// Tri selon les valeurs
$ao->asort(); // garde l'association clÃ©/valeur
foreach ($ao as $k => $v) {
    echo "$k => $v" . PHP_EOL; // a=>1, b=>2, c=>3
}

// Remplacer tout le contenu
$ao->exchangeArray(["x" => 10, "y" => 20]);
print_r($ao->getArrayCopy());
```

### Quelques itÃ©rateurs SPL utiles (pour aller plus loin)
- `ArrayIterator`, `CachingIterator` (mise en cache), `FilterIterator` (filtrer), `RegexIterator` (regex), `LimitIterator` (fenÃªtrage).
  
Exemple de **filtre** :

```php
<?php
class PositiveFilter extends FilterIterator {
    public function accept(): bool {
        return $this->current() > 0;
    }
}
$it = new PositiveFilter(new ArrayIterator([-2, 3, 0, 5, -1]));
foreach ($it as $v) echo $v . PHP_EOL; // 3, 5
```

---

## <span style="color:magenta;">Construire une Collection TypÃ©e (recommandÃ©)</span> ğŸ§±

CrÃ©er une **collection dÃ©diÃ©e** rend lâ€™API **claire**, **typÃ©e**, **testable**.  
On combine souvent : `IteratorAggregate` (itÃ©ration), `Countable` (taille), `ArrayAccess` (accÃ¨s type tableau â€“ optionnel).

```php
<?php
// Exemple simple : une collection de produits (nom, prix).
final class Product {
    public function __construct(
        public string $name,
        public float $price
    ) {}
}

final class ProductCollection implements IteratorAggregate, Countable {
    /** @var Product[] */
    private array $items = [];

    public function __construct(Product ...$products) {
        foreach ($products as $p) { $this->add($p); }
    }

    public function add(Product $product): void {
        $this->items[] = $product;
    }

    /** @return Traversable<Product> */
    public function getIterator(): Traversable {
        return new ArrayIterator($this->items);
    }

    public function count(): int { return count($this->items); }

    /** Filtre via callback typÃ©e */
    public function filter(callable $predicate): self {
        $out = new self();
        foreach ($this->items as $p) {
            if ($predicate($p)) { $out->add($p); }
        }
        return $out;
    }

    /** Mappe vers des scalaires/objets */
    public function map(callable $mapper): array {
        $result = [];
        foreach ($this->items as $p) { $result[] = $mapper($p); }
        return $result;
    }

    /** RÃ©duction (ex: somme des prix) */
    public function reduce(callable $reducer, mixed $initial): mixed {
        $acc = $initial;
        foreach ($this->items as $p) { $acc = $reducer($acc, $p); }
        return $acc;
    }
}

// --- DÃ©monstration ---
$pc = new ProductCollection(
    new Product("Clavier", 49.9),
    new Product("Souris", 29.0),
    new Product("Ã‰cran", 199.0),
);

// ItÃ©ration typÃ©e
foreach ($pc as $p) {
    echo "{$p->name} - {$p->price}â‚¬" . PHP_EOL;
}

// Filtrer (> 50â‚¬), mapper noms, sommer les prix
$chers = $pc->filter(fn(Product $p) => $p->price > 50);
$noms  = $chers->map(fn(Product $p) => $p->name);
$total = $pc->reduce(fn($acc, Product $p) => $acc + $p->price, 0);

print_r($noms);        // ["Ã‰cran"]
echo "Total: $totalâ‚¬"; // Total: 277.9â‚¬
```

> ğŸ¯ BÃ©nÃ©fices : API dÃ©diÃ©e, type-safety dâ€™usage, point central pour les **invariants** (ex. empÃªcher les `null`, valider les valeurs, etc.).

---

## <span style="color:magenta;">OpÃ©rations courantes â€œfaÃ§on collectionâ€</span> ğŸ§ª

MÃªme sans collection custom, vous pouvez composer avec les fonctions natives :

```php
<?php
$nums = [1, 2, 3, 4, 5];

// map
$doubles = array_map(fn($n) => $n * 2, $nums); // [2,4,6,8,10]

// filter
$pairs = array_filter($nums, fn($n) => $n % 2 === 0); // [2,4]

// reduce
$sum = array_reduce($nums, fn($acc, $n) => $acc + $n, 0); // 15
```

---

## <span style="color:magenta;">InterfaÃ§age & Conversion</span> ğŸ”„

- **Tableau â‡„ ArrayObject** : `new ArrayObject($arr)`, `$obj->getArrayCopy()`.
- **SPL â‡„ Tableau** : itÃ©ration et construction manuelle (ex. vider une `SplPriorityQueue` dans un tableau).
- **JSON** : `json_encode($arr)`, `json_decode($json, true)` pour obtenir un **tableau associatif**.

---

## <span style="color:magenta;">Bonnes pratiques & piÃ¨ges courants</span> ğŸ›¡ï¸

- `SplPriorityQueue` : par dÃ©faut, lâ€™itÃ©ration **consomme** les Ã©lÃ©ments. Utilisez `setExtractFlags()` et sachez quâ€™un `foreach` vide la structure selon le mode.
- `SplFixedArray` : dimension **fixe** â†’ adapter la taille avant affectation.
- `SplObjectStorage` : deux objets distincts **mÃªme contenu** â‰  objet identique (basÃ© sur lâ€™identitÃ©/empreinte dâ€™objet).
- PrÃ©fÃ©rez **collections typÃ©es** pour **encapsuler les rÃ¨gles** (ex. pas de produit au prix nÃ©gatif).
- SÃ©parez **donnÃ©es** et **prÃ©sentation** : une collection ne devrait pas `echo` directement ; exposez une API (itÃ©ration, map/reduce) et affichez hors de la collection.

---

## <span style="color:magenta;">Quand choisir quelle collection ?</span> ğŸ¯

- **Tableau** : cas gÃ©nÃ©ral, simplicitÃ©, interop (JSON, libs, frameworks).  
- **`SplStack`/`SplQueue`** : logique LIFO/FIFO claire, structures de flux.  
- **`SplPriorityQueue`** : ordonnanceur, tÃ¢ches pondÃ©rÃ©es, â€œto-dosâ€ urgents.  
- **`SplHeap`** : besoin frÃ©quent du **max/min**.  
- **`SplFixedArray`** : grands volumes Ã  taille connue, mÃ©moire optimisÃ©e.  
- **`SplObjectStorage`** : gÃ©rer un **set dâ€™objets** (unicitÃ©), mÃ©tadonnÃ©es par objet.

---

## <span style="color:magenta;">RÃ©sumÃ©</span> ğŸ§ 

- Les **collections PHP** ne se limitent pas aux tableaux : la **SPL** apporte des **structures optimisÃ©es**.  
- `ArrayObject` et les **interfaces SPL** (`IteratorAggregate`, `Countable`â€¦) permettent de **crÃ©er vos collections typÃ©es** et **expressives**.  
- Les opÃ©rations fonctionnelles (**map, filter, reduce**) se combinent trÃ¨s bien avec les collections pour Ã©crire un code **lisible** et **dÃ©claratif**.

---

## <span style="color:magenta;">Conclusion</span> ğŸ‰

MaÃ®triser les **collections** en PHP, câ€™est choisir la **bonne structure** pour le **bon usage**, amÃ©liorer la **clartÃ©** du code et **sÃ©curiser** vos donnÃ©es via des invariants.  
Au prochain cours, nous verrons comment **aller plus loin** avec des **collections avancÃ©es** (patterns dâ€™itÃ©ration, dÃ©corateurs, et intÃ©gration dans des frameworks modernes).

ğŸš€ *EntraÃ®nez-vous Ã  remplacer des tableaux â€œlibresâ€ par des collections typÃ©es : votre code gagnera en robustesse et en maintenabilitÃ© !*
