# <span style="color:magenta;">Introduction aux Collections en PHP</span> 🗃️

Les **collections** regroupent des structures de données et des outils permettant de **stocker**, **organiser** et **manipuler** des ensembles d’éléments de manière expressive et sûre.  
En PHP, au-delà des **tableaux** (abordés au cours précédent), on dispose d’un arsenal très utile : la **SPL** (*Standard PHP Library*) avec ses **structures spécialisées** (listes, piles, files, files de priorité, tas, etc.), des **objets tableaux** (`ArrayObject`), ainsi que la possibilité de créer **vos propres collections typées** via `IteratorAggregate`, `Countable`, `ArrayAccess`, etc.

Ce cours présente les **collections natives** (SPL) et montre comment construire une **collection sur mesure** propre et testable.

---

## <span style="color:magenta;">Panorama rapide</span> 🧭

- **Tableaux PHP** : polyvalents, indexés/associatifs, base de 90% des manipulations.  
- **SPL – Structures spécialisées** :
  - `SplDoublyLinkedList` (liste doublement chaînée)
  - `SplStack` (pile LIFO)
  - `SplQueue` (file FIFO)
  - `SplPriorityQueue` (file avec priorités)
  - `SplHeap`, `SplMaxHeap`, `SplMinHeap` (tas / heaps)
  - `SplFixedArray` (tableau à taille fixe, mémoire optimisée)
  - `SplObjectStorage` (ensemble d’objets – *set* d’objets)
- **Collections “objet” sur mesure** :
  - `ArrayObject` (un tableau… en objet)
  - Collections typées via `IteratorAggregate` + `Countable` (pattern recommandé)

---

## <span style="color:magenta;">SPL : Listes, Piles, Files</span> 🧱

### `SplDoublyLinkedList` – Liste doublement chaînée 🔗
Insertion/suppression **en tête/en queue** en O(1), itération flexible.

```php
<?php
$list = new SplDoublyLinkedList();
$list->setIteratorMode(SplDoublyLinkedList::IT_MODE_KEEP); // conserve les éléments lors de l'itération
$list->push("Alice");  // fin
$list->unshift("Bob"); // début

foreach ($list as $item) {
    echo $item . PHP_EOL; // Bob, Alice
}
```

### `SplStack` – Pile (LIFO) 📚
Dernier entré, premier sorti.

```php
<?php
$stack = new SplStack();
$stack->push("A");
$stack->push("B");
echo $stack->pop(); // B
echo $stack->pop(); // A
```

### `SplQueue` – File (FIFO) 🚶
Premier entré, premier sorti.

```php
<?php
$q = new SplQueue();
$q->enqueue("Tâche1");
$q->enqueue("Tâche2");
echo $q->dequeue(); // Tâche1
echo $q->dequeue(); // Tâche2
```

---

## <span style="color:magenta;">Priorités et Tas (Heaps)</span> 🥇

### `SplPriorityQueue` – File à priorité
Chaque élément a une **priorité**. Attention : selon le mode, l’itération peut **extraire** les éléments.

```php
<?php
$pq = new SplPriorityQueue();
$pq->setExtractFlags(SplPriorityQueue::EXTR_DATA); // ne renvoyer que la donnée
$pq->insert("Urgent", 100);
$pq->insert("Normal", 10);
$pq->insert("Faible", 1);

while (!$pq->isEmpty()) {
    echo $pq->extract() . PHP_EOL; // Urgent, Normal, Faible
}
```

### `SplMaxHeap` / `SplMinHeap` – Tas max/min
Structure binaire optimisée pour récupérer **max**/**min** en O(1), insertion/suppression en O(log n).

```php
<?php
$maxHeap = new SplMaxHeap();
foreach ([3, 10, 6, 1] as $n) $maxHeap->insert($n);

echo $maxHeap->extract() . PHP_EOL; // 10
echo $maxHeap->extract() . PHP_EOL; // 6
```

---

## <span style="color:magenta;">Tableaux spécialisés</span> 🧰

### `SplFixedArray` – Tableau à taille fixe
Moins de surcoût mémoire que les tableaux dynamiques.

```php
<?php
$fa = new SplFixedArray(3);
$fa[0] = "A";
$fa[1] = "B";
$fa[2] = "C";
// $fa[3] = "D"; // ⚠️ Erreur : hors limites
foreach ($fa as $v) { echo $v . PHP_EOL; }
```

### `SplObjectStorage` – Ensemble d’objets (Set) 🧑‍🤝‍🧑
Stocke **des objets uniques**. Permet d’associer des **métadonnées** à chaque objet.

```php
<?php
class User { public function __construct(public string $name) {} }

$u1 = new User("Alice");
$u2 = new User("Bob");

$store = new SplObjectStorage();
$store->attach($u1, ["role" => "admin"]);
$store->attach($u2, ["role" => "editor"]);

foreach ($store as $obj) {
    $meta = $store[$obj]; // métadonnées
    echo $obj->name . " (" . $meta["role"] . ")" . PHP_EOL;
}
```

---

## <span style="color:magenta;">ArrayObject & Itérateurs</span> 🧾

### `ArrayObject` – Un tableau “objet”
Tri, échange, itération via `IteratorAggregate`.

```php
<?php
$ao = new ArrayObject(["c" => 3, "a" => 1, "b" => 2]);

// Tri selon les valeurs
$ao->asort(); // garde l'association clé/valeur
foreach ($ao as $k => $v) {
    echo "$k => $v" . PHP_EOL; // a=>1, b=>2, c=>3
}

// Remplacer tout le contenu
$ao->exchangeArray(["x" => 10, "y" => 20]);
print_r($ao->getArrayCopy());
```

### Quelques itérateurs SPL utiles (pour aller plus loin)
- `ArrayIterator`, `CachingIterator` (mise en cache), `FilterIterator` (filtrer), `RegexIterator` (regex), `LimitIterator` (fenêtrage).
  
Exemple de **filtre** :

```php
<?php
class PositiveFilter extends FilterIterator {
    public function accept(): bool {
        return $this->current() > 0;
    }
}
$it = new PositiveFilter(new ArrayIterator([-2, 3, 0, 5, -1]));
foreach ($it as $v) echo $v . PHP_EOL; // 3, 5
```

---

## <span style="color:magenta;">Construire une Collection Typée (recommandé)</span> 🧱

Créer une **collection dédiée** rend l’API **claire**, **typée**, **testable**.  
On combine souvent : `IteratorAggregate` (itération), `Countable` (taille), `ArrayAccess` (accès type tableau – optionnel).

```php
<?php
// Exemple simple : une collection de produits (nom, prix).
final class Product {
    public function __construct(
        public string $name,
        public float $price
    ) {}
}

final class ProductCollection implements IteratorAggregate, Countable {
    /** @var Product[] */
    private array $items = [];

    public function __construct(Product ...$products) {
        foreach ($products as $p) { $this->add($p); }
    }

    public function add(Product $product): void {
        $this->items[] = $product;
    }

    /** @return Traversable<Product> */
    public function getIterator(): Traversable {
        return new ArrayIterator($this->items);
    }

    public function count(): int { return count($this->items); }

    /** Filtre via callback typée */
    public function filter(callable $predicate): self {
        $out = new self();
        foreach ($this->items as $p) {
            if ($predicate($p)) { $out->add($p); }
        }
        return $out;
    }

    /** Mappe vers des scalaires/objets */
    public function map(callable $mapper): array {
        $result = [];
        foreach ($this->items as $p) { $result[] = $mapper($p); }
        return $result;
    }

    /** Réduction (ex: somme des prix) */
    public function reduce(callable $reducer, mixed $initial): mixed {
        $acc = $initial;
        foreach ($this->items as $p) { $acc = $reducer($acc, $p); }
        return $acc;
    }
}

// --- Démonstration ---
$pc = new ProductCollection(
    new Product("Clavier", 49.9),
    new Product("Souris", 29.0),
    new Product("Écran", 199.0),
);

// Itération typée
foreach ($pc as $p) {
    echo "{$p->name} - {$p->price}€" . PHP_EOL;
}

// Filtrer (> 50€), mapper noms, sommer les prix
$chers = $pc->filter(fn(Product $p) => $p->price > 50);
$noms  = $chers->map(fn(Product $p) => $p->name);
$total = $pc->reduce(fn($acc, Product $p) => $acc + $p->price, 0);

print_r($noms);        // ["Écran"]
echo "Total: $total€"; // Total: 277.9€
```

> 🎯 Bénéfices : API dédiée, type-safety d’usage, point central pour les **invariants** (ex. empêcher les `null`, valider les valeurs, etc.).

---

## <span style="color:magenta;">Opérations courantes “façon collection”</span> 🧪

Même sans collection custom, vous pouvez composer avec les fonctions natives :

```php
<?php
$nums = [1, 2, 3, 4, 5];

// map
$doubles = array_map(fn($n) => $n * 2, $nums); // [2,4,6,8,10]

// filter
$pairs = array_filter($nums, fn($n) => $n % 2 === 0); // [2,4]

// reduce
$sum = array_reduce($nums, fn($acc, $n) => $acc + $n, 0); // 15
```

---

## <span style="color:magenta;">Interfaçage & Conversion</span> 🔄

- **Tableau ⇄ ArrayObject** : `new ArrayObject($arr)`, `$obj->getArrayCopy()`.
- **SPL ⇄ Tableau** : itération et construction manuelle (ex. vider une `SplPriorityQueue` dans un tableau).
- **JSON** : `json_encode($arr)`, `json_decode($json, true)` pour obtenir un **tableau associatif**.

---

## <span style="color:magenta;">Bonnes pratiques & pièges courants</span> 🛡️

- `SplPriorityQueue` : par défaut, l’itération **consomme** les éléments. Utilisez `setExtractFlags()` et sachez qu’un `foreach` vide la structure selon le mode.
- `SplFixedArray` : dimension **fixe** → adapter la taille avant affectation.
- `SplObjectStorage` : deux objets distincts **même contenu** ≠ objet identique (basé sur l’identité/empreinte d’objet).
- Préférez **collections typées** pour **encapsuler les règles** (ex. pas de produit au prix négatif).
- Séparez **données** et **présentation** : une collection ne devrait pas `echo` directement ; exposez une API (itération, map/reduce) et affichez hors de la collection.

---

## <span style="color:magenta;">Quand choisir quelle collection ?</span> 🎯

- **Tableau** : cas général, simplicité, interop (JSON, libs, frameworks).  
- **`SplStack`/`SplQueue`** : logique LIFO/FIFO claire, structures de flux.  
- **`SplPriorityQueue`** : ordonnanceur, tâches pondérées, “to-dos” urgents.  
- **`SplHeap`** : besoin fréquent du **max/min**.  
- **`SplFixedArray`** : grands volumes à taille connue, mémoire optimisée.  
- **`SplObjectStorage`** : gérer un **set d’objets** (unicité), métadonnées par objet.

---

## <span style="color:magenta;">Résumé</span> 🧠

- Les **collections PHP** ne se limitent pas aux tableaux : la **SPL** apporte des **structures optimisées**.  
- `ArrayObject` et les **interfaces SPL** (`IteratorAggregate`, `Countable`…) permettent de **créer vos collections typées** et **expressives**.  
- Les opérations fonctionnelles (**map, filter, reduce**) se combinent très bien avec les collections pour écrire un code **lisible** et **déclaratif**.

---

## <span style="color:magenta;">Conclusion</span> 🎉

Maîtriser les **collections** en PHP, c’est choisir la **bonne structure** pour le **bon usage**, améliorer la **clarté** du code et **sécuriser** vos données via des invariants.  
Au prochain cours, nous verrons comment **aller plus loin** avec des **collections avancées** (patterns d’itération, décorateurs, et intégration dans des frameworks modernes).

🚀 *Entraînez-vous à remplacer des tableaux “libres” par des collections typées : votre code gagnera en robustesse et en maintenabilité !*
