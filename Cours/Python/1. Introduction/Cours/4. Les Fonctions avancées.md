# <span style="color:lime">Les Fonctions AvancÃ©es</span> ğŸš€ (version dÃ©butants+ et ultra claire)

---

## <span style="color:lime">1) `*args` et `**kwargs`</span> ğŸ§º

**Image mentale :**  
- `*args` = **sac Ã  dos** â†’ tu peux mettre **autant dâ€™arguments** positionnels que tu veux.  
- `**kwargs` = **cartable Ã©tiquetÃ©** â†’ tu mets des paires **nom=valeur** (arguments nommÃ©s).

**Ã€ quoi Ã§a sert ?**  
- Ã‰crire des fonctions qui acceptent un **nombre variable** dâ€™arguments.  
- CrÃ©er des API **flexibles** (ex. options additionnelles).

```python
def additionner(*nombres):
    # nombres est un tuple, ex: (1, 2, 3, 4)
    return sum(nombres)

def configurer(**options):
    # options est un dict, ex: {'theme': 'dark', 'debug': True}
    return options

print(additionner(1, 2, 3, 4))                 # 10
print(configurer(theme="dark", debug=True))    # {'theme': 'dark', 'debug': True}
```

**Quand lâ€™utiliser ?**  
- Quand tu ne connais pas **Ã  lâ€™avance** le nombre dâ€™arguments.  
- Pour passer des **options** sans alourdir la signature.

**Ã€ Ã©viter :**  
- En abuser partout : Ã§a peut **cacher** des erreurs dâ€™appel (mauvais noms dâ€™options, ordre, etc.).  
- MÃ©langer `*args`/`**kwargs` sans nÃ©cessitÃ© â€” privilÃ©gie des **paramÃ¨tres clairs**.

---

## <span style="color:lime">2) Valeurs par dÃ©faut : attention aux *mutables*</span> âš ï¸

**ProblÃ¨me classique :**  
Les valeurs par dÃ©faut ne sont **crÃ©Ã©es quâ€™une seule fois** (au moment de la dÃ©finition).  
Si tu mets une **liste/dict** en valeur par dÃ©faut, **tous les appels** partagent le **mÃªme objet**.

```python
# âŒ Mauvais : la mÃªme liste est rÃ©utilisÃ©e Ã  chaque appel
def ajouter_mauvais(x, liste=[]):
    liste.append(x)
    return liste

# âœ… Bon : on crÃ©e une nouvelle liste si None
def ajouter_bon(x, liste=None):
    if liste is None:
        liste = []
    liste.append(x)
    return liste
```

**RÃ¨gle en 1 ligne :**  
> Valeur par dÃ©faut **mutable** â†’ utiliser **None** puis crÃ©er lâ€™objet **dans** la fonction.

---

## <span style="color:lime">3) Les fonctions sont des objets</span> ğŸ§ 

**IdÃ©e clÃ© :**  
Une fonction est une **valeur comme une autre** : tu peux **la stocker**, la **passer** en paramÃ¨tre, ou la **retourner**.

```python
def carre(x): 
    return x * x

def appliquer(f, valeur):
    return f(valeur)

print(appliquer(carre, 6))  # 36
```

**Ã€ quoi Ã§a sert ?**  
- Composer du comportement (appliquer une **stratÃ©gie** passÃ©e en paramÃ¨tre).  
- Construire des pipelines de traitement (ex. en data).

---

## <span style="color:lime">4) Lambdas & Closures</span> ğŸ§·

### Lambdas (mini-fonctions anonymes)
- Une **ligne**, **une expression**, pas de nom â†’ pratique pour les **petites clÃ©s de tri**, filtres, etc.

```python
notes = [("Alice", 14), ("Bob", 9), ("ChloÃ©", 16)]
notes_triees = sorted(notes, key=lambda t: t[1], reverse=True)
```

### Closures (fonction qui â€œretientâ€ des variables)
- La fonction **retient** des valeurs de son environnement au moment de sa crÃ©ation.

```python
def make_adder(n):
    def add(x):
        return x + n  # n est "capturÃ©"
    return add

plus10 = make_adder(10)
print(plus10(5))  # 15
```

**Quand câ€™est utile ?**  
- Pour **fabriquer** des fonctions sur mesure (ex. â€œajouter 10â€, â€œajouter TVA 20%â€, etc.).  
- Ã‰viter des classes pour des petits comportements paramÃ©trÃ©s.

---

## <span style="color:lime">5) GÃ©nÃ©rateurs & `yield`</span> âš™ï¸

**Image mentale :**  
Un gÃ©nÃ©rateur, câ€™est un **robinet** : il **donne une valeur Ã  la fois** quand on en a besoin.  
â†’ TrÃ¨s **Ã©conome en mÃ©moire**, surtout sur de **grandes** sÃ©quences.

```python
def pairs_jusqua(limit):
    n = 0
    while n <= limit:
        if n % 2 == 0:
            yield n        # "produit" une valeur
        n += 1

for p in pairs_jusqua(6):   # 0, 2, 4, 6
    print(p)
```

**Quand lâ€™utiliser ?**  
- Lecture de gros fichiers, flux, calculs paresseux (**lazy**).  
- Quand **tout stocker** en mÃ©moire serait trop coÃ»teux.

**Ã€ retenir :**  
- `yield` **interrompt** la fonction et **reprend** au mÃªme endroit au prochain appel.

---

## <span style="color:lime">6) DÃ©corateurs (aperÃ§u simple)</span> ğŸ€

**Image mentale :**  
Un dÃ©corateur, câ€™est un **emballage** autour dâ€™une fonction : on lui **ajoute un comportement** (log, timing, cache) **sans modifier** la fonction elle-mÃªme.

```python
import time

def timing(f):
    def wrapped(*a, **kw):
        t0 = time.perf_counter()
        r  = f(*a, **kw)
        dt = (time.perf_counter() - t0) * 1000
        print(f"{f.__name__} : {dt:.2f} ms")
        return r
    return wrapped

@timing
def travail():
    total = 0
    for _ in range(10_000):
        total += 1
    return total

travail()
```

**Quand lâ€™utiliser ?**  
- Ajouter un **log**, **mesurer** un temps dâ€™exÃ©cution, **vÃ©rifier** des droits, **mettre en cache** un rÃ©sultat.

**Ã€ Ã©viter :**  
- EnchaÃ®ner trop de dÃ©corateurs â†’ lecture compliquÃ©e.  
- Oublier de **documenter** ce que le dÃ©corateur ajoute.

---

## <span style="color:lime">7) RÃ©cursivitÃ© (aperÃ§u)</span> ğŸ”

**Principe :**  
Une fonction sâ€™appelle **elle-mÃªme** jusquâ€™Ã  atteindre un **cas de base** (arrÃªt).

```python
def factorielle(n):
    if n < 2:          # cas de base
        return 1
    return n * factorielle(n - 1)  # cas rÃ©cursif
```

**Quand lâ€™utiliser ?**  
- ProblÃ¨mes naturellement **rÃ©cursifs** : arbres, parcours, division et conquÃªte.  
- Sinon, une **boucle** est souvent plus simple et plus robuste (âš ï¸ profondeur dâ€™appel limitÃ©e).

---

## <span style="color:lime">8) Docstrings & Annotations de type</span> ğŸ“š

**Pourquoi ?**  
- Pour **expliquer** ce que fait la fonction (docstring).  
- Pour **indiquer** les types attendus/retournÃ©s (annotations) â†’ aide IDE/linters, meilleure **lisibilitÃ©**.

```python
from typing import Iterable, List

def flatten(nested: Iterable[Iterable[int]]) -> List[int]:
    """
    Aplatie un itÃ©rable d'itÃ©rables d'entiers en une liste.
    Args:
        nested: ex. [[1,2],[3]]
    Returns:
        [1, 2, 3]
    """
    out: List[int] = []
    for seq in nested:
        out.extend(seq)
    return out
```

**Ã€ retenir :**  
- Les types **nâ€™arrÃªtent pas** lâ€™exÃ©cution (ils sont **indicatifs**), mais ils **rÃ©duisent les erreurs** et amÃ©liorent lâ€™auto-complÃ©tion.

---

## <span style="color:lime">Erreurs frÃ©quentes & Anti-piÃ¨ges</span> ğŸ§¯

- **Mutable par dÃ©faut** (`[]`, `{}`) â†’ utiliser `None`, puis crÃ©er lâ€™objet **dans** la fonction.  
- Abuser de `*args/**kwargs` â†’ signatures floues, bugs silencieux.  
- DÃ©corateurs partout â†’ code difficile Ã  lire : documenter et rester **sobre**.  
- RÃ©cursivitÃ© sans **cas de base** clair â†’ boucle infinie / dÃ©passement de pile.  
- Oublier la **docstring** â†’ 3 lignes suffisent : but, params, retour.

---

## <span style="color:lime">Mini-Checklist avant dâ€™Ã©crire une fonction</span> âœ…

1) **But unique** (une seule responsabilitÃ©)  
2) **Nom clair** (verbe + complÃ©ment : `calculer_total`)  
3) **ParamÃ¨tres** nÃ©cessaires uniquement (Ã©vite le â€œfourre-toutâ€)  
4) **Valeurs par dÃ©faut** sÃ»res (pas de mutables)  
5) **Docstring** courte (but, paramÃ¨tres, retour)  
6) **Types** si possible (lisibilitÃ© + outils)  
7) **Tests rapides** (cas normal + cas limites)

---

## <span style="color:lime">RÃ©sumÃ© & Prochaines Ã©tapes</span> ğŸ§­

- Tu sais maintenant **quand** utiliser `*args/**kwargs`, **Ã©viter** le piÃ¨ge des valeurs par dÃ©faut **mutables**, employer **lambdas/closures**, produire des valeurs avec **gÃ©nÃ©rateurs**, **enrichir** avec des **dÃ©corateurs**, et **reconnaÃ®tre** quand la **rÃ©cursivitÃ©** est adaptÃ©e.  
- Prochaine Ã©tape : **pratique guidÃ©e** â†’ rÃ©Ã©cris de petites fonctions â€œclassiquesâ€ (validation, formatage, calcul) **en appliquant 1 ou 2 outils avancÃ©s** Ã  la fois (ex. `*args` + docstring, puis gÃ©nÃ©rateur + types).  
- Avance **pas Ã  pas** : lâ€™important est de **comprendre** et **reconnaÃ®tre** le bon outil pour le bon problÃ¨me.
