# <span style="color:lime">Les Fonctions Avancées</span> 🚀 (version débutants+ et ultra claire)

---

## <span style="color:lime">1) `*args` et `**kwargs`</span> 🧺

**Image mentale :**  
- `*args` = **sac à dos** → tu peux mettre **autant d’arguments** positionnels que tu veux.  
- `**kwargs` = **cartable étiqueté** → tu mets des paires **nom=valeur** (arguments nommés).

**À quoi ça sert ?**  
- Écrire des fonctions qui acceptent un **nombre variable** d’arguments.  
- Créer des API **flexibles** (ex. options additionnelles).

```python
def additionner(*nombres):
    # nombres est un tuple, ex: (1, 2, 3, 4)
    return sum(nombres)

def configurer(**options):
    # options est un dict, ex: {'theme': 'dark', 'debug': True}
    return options

print(additionner(1, 2, 3, 4))                 # 10
print(configurer(theme="dark", debug=True))    # {'theme': 'dark', 'debug': True}
```

**Quand l’utiliser ?**  
- Quand tu ne connais pas **à l’avance** le nombre d’arguments.  
- Pour passer des **options** sans alourdir la signature.

**À éviter :**  
- En abuser partout : ça peut **cacher** des erreurs d’appel (mauvais noms d’options, ordre, etc.).  
- Mélanger `*args`/`**kwargs` sans nécessité — privilégie des **paramètres clairs**.

---

## <span style="color:lime">2) Valeurs par défaut : attention aux *mutables*</span> ⚠️

**Problème classique :**  
Les valeurs par défaut ne sont **créées qu’une seule fois** (au moment de la définition).  
Si tu mets une **liste/dict** en valeur par défaut, **tous les appels** partagent le **même objet**.

```python
# ❌ Mauvais : la même liste est réutilisée à chaque appel
def ajouter_mauvais(x, liste=[]):
    liste.append(x)
    return liste

# ✅ Bon : on crée une nouvelle liste si None
def ajouter_bon(x, liste=None):
    if liste is None:
        liste = []
    liste.append(x)
    return liste
```

**Règle en 1 ligne :**  
> Valeur par défaut **mutable** → utiliser **None** puis créer l’objet **dans** la fonction.

---

## <span style="color:lime">3) Les fonctions sont des objets</span> 🧠

**Idée clé :**  
Une fonction est une **valeur comme une autre** : tu peux **la stocker**, la **passer** en paramètre, ou la **retourner**.

```python
def carre(x): 
    return x * x

def appliquer(f, valeur):
    return f(valeur)

print(appliquer(carre, 6))  # 36
```

**À quoi ça sert ?**  
- Composer du comportement (appliquer une **stratégie** passée en paramètre).  
- Construire des pipelines de traitement (ex. en data).

---

## <span style="color:lime">4) Lambdas & Closures</span> 🧷

### Lambdas (mini-fonctions anonymes)
- Une **ligne**, **une expression**, pas de nom → pratique pour les **petites clés de tri**, filtres, etc.

```python
notes = [("Alice", 14), ("Bob", 9), ("Chloé", 16)]
notes_triees = sorted(notes, key=lambda t: t[1], reverse=True)
```

### Closures (fonction qui “retient” des variables)
- La fonction **retient** des valeurs de son environnement au moment de sa création.

```python
def make_adder(n):
    def add(x):
        return x + n  # n est "capturé"
    return add

plus10 = make_adder(10)
print(plus10(5))  # 15
```

**Quand c’est utile ?**  
- Pour **fabriquer** des fonctions sur mesure (ex. “ajouter 10”, “ajouter TVA 20%”, etc.).  
- Éviter des classes pour des petits comportements paramétrés.

---

## <span style="color:lime">5) Générateurs & `yield`</span> ⚙️

**Image mentale :**  
Un générateur, c’est un **robinet** : il **donne une valeur à la fois** quand on en a besoin.  
→ Très **économe en mémoire**, surtout sur de **grandes** séquences.

```python
def pairs_jusqua(limit):
    n = 0
    while n <= limit:
        if n % 2 == 0:
            yield n        # "produit" une valeur
        n += 1

for p in pairs_jusqua(6):   # 0, 2, 4, 6
    print(p)
```

**Quand l’utiliser ?**  
- Lecture de gros fichiers, flux, calculs paresseux (**lazy**).  
- Quand **tout stocker** en mémoire serait trop coûteux.

**À retenir :**  
- `yield` **interrompt** la fonction et **reprend** au même endroit au prochain appel.

---

## <span style="color:lime">6) Décorateurs (aperçu simple)</span> 🎀

**Image mentale :**  
Un décorateur, c’est un **emballage** autour d’une fonction : on lui **ajoute un comportement** (log, timing, cache) **sans modifier** la fonction elle-même.

```python
import time

def timing(f):
    def wrapped(*a, **kw):
        t0 = time.perf_counter()
        r  = f(*a, **kw)
        dt = (time.perf_counter() - t0) * 1000
        print(f"{f.__name__} : {dt:.2f} ms")
        return r
    return wrapped

@timing
def travail():
    total = 0
    for _ in range(10_000):
        total += 1
    return total

travail()
```

**Quand l’utiliser ?**  
- Ajouter un **log**, **mesurer** un temps d’exécution, **vérifier** des droits, **mettre en cache** un résultat.

**À éviter :**  
- Enchaîner trop de décorateurs → lecture compliquée.  
- Oublier de **documenter** ce que le décorateur ajoute.

---

## <span style="color:lime">7) Récursivité (aperçu)</span> 🔁

**Principe :**  
Une fonction s’appelle **elle-même** jusqu’à atteindre un **cas de base** (arrêt).

```python
def factorielle(n):
    if n < 2:          # cas de base
        return 1
    return n * factorielle(n - 1)  # cas récursif
```

**Quand l’utiliser ?**  
- Problèmes naturellement **récursifs** : arbres, parcours, division et conquête.  
- Sinon, une **boucle** est souvent plus simple et plus robuste (⚠️ profondeur d’appel limitée).

---

## <span style="color:lime">8) Docstrings & Annotations de type</span> 📚

**Pourquoi ?**  
- Pour **expliquer** ce que fait la fonction (docstring).  
- Pour **indiquer** les types attendus/retournés (annotations) → aide IDE/linters, meilleure **lisibilité**.

```python
from typing import Iterable, List

def flatten(nested: Iterable[Iterable[int]]) -> List[int]:
    """
    Aplatie un itérable d'itérables d'entiers en une liste.
    Args:
        nested: ex. [[1,2],[3]]
    Returns:
        [1, 2, 3]
    """
    out: List[int] = []
    for seq in nested:
        out.extend(seq)
    return out
```

**À retenir :**  
- Les types **n’arrêtent pas** l’exécution (ils sont **indicatifs**), mais ils **réduisent les erreurs** et améliorent l’auto-complétion.

---

## <span style="color:lime">Erreurs fréquentes & Anti-pièges</span> 🧯

- **Mutable par défaut** (`[]`, `{}`) → utiliser `None`, puis créer l’objet **dans** la fonction.  
- Abuser de `*args/**kwargs` → signatures floues, bugs silencieux.  
- Décorateurs partout → code difficile à lire : documenter et rester **sobre**.  
- Récursivité sans **cas de base** clair → boucle infinie / dépassement de pile.  
- Oublier la **docstring** → 3 lignes suffisent : but, params, retour.

---

## <span style="color:lime">Mini-Checklist avant d’écrire une fonction</span> ✅

1) **But unique** (une seule responsabilité)  
2) **Nom clair** (verbe + complément : `calculer_total`)  
3) **Paramètres** nécessaires uniquement (évite le “fourre-tout”)  
4) **Valeurs par défaut** sûres (pas de mutables)  
5) **Docstring** courte (but, paramètres, retour)  
6) **Types** si possible (lisibilité + outils)  
7) **Tests rapides** (cas normal + cas limites)

---

## <span style="color:lime">Résumé & Prochaines étapes</span> 🧭

- Tu sais maintenant **quand** utiliser `*args/**kwargs`, **éviter** le piège des valeurs par défaut **mutables**, employer **lambdas/closures**, produire des valeurs avec **générateurs**, **enrichir** avec des **décorateurs**, et **reconnaître** quand la **récursivité** est adaptée.  
- Prochaine étape : **pratique guidée** → réécris de petites fonctions “classiques” (validation, formatage, calcul) **en appliquant 1 ou 2 outils avancés** à la fois (ex. `*args` + docstring, puis générateur + types).  
- Avance **pas à pas** : l’important est de **comprendre** et **reconnaître** le bon outil pour le bon problème.
