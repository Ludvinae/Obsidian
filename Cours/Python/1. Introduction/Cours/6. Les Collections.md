# <span style="color:lime">Introduction aux Collections</span> 📦

En Python, une **collection** est une structure permettant de stocker **plusieurs éléments**.  
Les principales collections intégrées sont : **liste** (`list`), **tuple** (`tuple`), **ensemble** (`set`) et **dictionnaire** (`dict`).  
Elles diffèrent par l’**ordre**, la **mutabilité**, l’**unicité** des éléments, l’**indexation** et les **opérations** possibles.

> 🔎 **Différence générale avec une liste :**  
> La **liste** est **ordonnée**, **modifiable**, **indexable** et **accepte les doublons**.  
> Les autres collections changent au moins un de ces aspects (immutabilité pour `tuple`, unicité non ordonnée pour `set`, association clé→valeur pour `dict`).

---

## <span style="color:lime">Listes</span> 📋

Les **listes** modélisent des **séquences ordonnées** d’éléments. Elles sont **mutables** (on peut modifier, insérer, supprimer).

```python
# Déclaration
nombres = [1, 2, 3, 4, 5]
noms = ["Alice", "Bob", "Charlie"]
mixte = [1, "Deux", True, 3.14]

# Opérations usuelles
nombres.append(6)           # ajout en fin
nombres.insert(1, 99)       # insertion à l’indice 1
nombres[2] = 100            # modification
val = nombres.pop()         # retire et retourne le dernier
sous = nombres[1:4]         # slicing
```

**Quand utiliser une liste ?**
- Quand l’**ordre** et l’**indexation** comptent (accéder à l’élément i).
- Quand on a besoin de **modifier** fréquemment le contenu (ajouts, suppressions).

---

## <span style="color:lime">Tuples</span> 📦

Un **tuple** est une **séquence immuable** : une fois créé, il ne change plus.  
On l’utilise pour des **paquets de valeurs** qui forment un **tout logique** (coordonnées, date, enregistrement simple…).

```python
# Déclaration
coordonnees = (10, 20)
couleurs = ("rouge", "vert", "bleu")

# Accès (comme une liste)
x = coordonnees[0]
y = coordonnees[1]

# Dépack (unpacking)
r, v, b = couleurs
```

**Par rapport à une liste :**
- **Immuable** → plus sûr et souvent plus léger en mémoire.
- Peut servir de **clé** dans un dictionnaire (si ses éléments sont eux-mêmes hachables).

**À savoir :**
- `(42,)` tuple à **un seul élément** (la virgule est obligatoire).  
- Un tuple peut contenir des objets **mutables** (ex. liste), mais le **tuple lui-même** reste immuable.

---

## <span style="color:lime">Ensembles (sets)</span> 🛑

Un **ensemble** stocke des **éléments uniques** (**pas de doublon**) et est **non ordonné** → **pas d’index**.  
Idéal pour tester l’**appartenance** rapidement et faire des **opérations ensemblistes** (union, intersection…).

```python
# Déclaration (attention : {} seul crée un dict vide !)
lettres = {"a", "b", "c"}
nombres = {1, 2, 3, 4, 5}
vide = set()  # ensemble vide

# Unicité
S = {1, 2, 2, 3}         # {1, 2, 3}

# Opérations ensemblistes
A = {1, 2, 3}; B = {3, 4}
print(A | B)             # union → {1, 2, 3, 4}
print(A & B)             # intersection → {3}
print(A - B)             # différence → {1, 2}
print(A ^ B)             # diff. symétrique → {1, 2, 4}

# Test d’appartenance performant
2 in A   # True
```

**Par rapport à une liste :**
- **Uniquement des valeurs uniques** (dé-doublonnage simple).
- **Non ordonné** et **non indexable**.
- Tests `in` généralement **plus rapides** (hachage).

**À savoir :**
- Les éléments doivent être **hachables** (immutables comme `int`, `str`, `tuple` de hachables).  
- Besoin d’un ensemble **immuable** ? → `frozenset({...})` (hachable, utilisable comme clé de dict).

---

## <span style="color:lime">Dictionnaires</span> 📚

Un **dictionnaire** associe des **clés** à des **valeurs** (mapping).  
Depuis Python 3.7+, l’**ordre d’insertion** est **préservé**.

```python
# Déclaration
personne = {"nom": "Alice", "age": 30, "ville": "Paris"}
etudiant = {"matiere": "Math", "note": 18, "annee": 2022}

# Accès & mise à jour
print(personne["nom"])             # "Alice"
personne["age"] = 31               # modification
personne["email"] = "a@ex.com"     # ajout
personne.pop("ville")              # suppression

# Accès sûr
print(etudiant.get("option", "aucune"))    # évite KeyError

# Parcours
for k, v in personne.items():
    print(k, "→", v)

# Fusion (3.9+)
d1 = {"a": 1}; d2 = {"b": 2}
d3 = d1 | d2                          # {'a': 1, 'b': 2}
```

**Par rapport à une liste :**
- Accès par **clé** (nommée) au lieu d’un **indice** numérique.
- Très pratique pour des **données structurées** (étiquetées).

**À savoir :**
- Les **clés** doivent être **hachables** (ex. `str`, `int`, `tuple` de hachables).
- `in` sur un dict teste la présence d’une **clé** (pas d’une valeur).

---

## <span style="color:lime">Compréhensions & constructions rapides</span> ⚡

Les **compréhensions** existent pour `list`, `set` et `dict` (pas besoin de boucles explicites pour des transformations simples).

```python
# List comprehension
carres = [x*x for x in range(6)]                 # [0, 1, 4, 9, 16, 25]

# Set comprehension (unicité)
pairs = {x for x in range(10) if x % 2 == 0}     # {0, 2, 4, 6, 8}

# Dict comprehension (clé → valeur)
carres_map = {x: x*x for x in range(5)}          # {0:0, 1:1, 2:4, 3:9, 4:16}
```

---

## <span style="color:lime">Choisir la bonne collection</span> 🧭

- **Liste (`list`)** : suite **ordonnée**, **modifiable**, avec **doublons** → indexation et parcours séquentiel.
- **Tuple (`tuple`)** : suite **ordonnée**, **immuable** → paquet de valeurs **figé** (clé possible en dict).
- **Ensemble (`set`)** : **unicité**, **non ordonné**, **test d’appartenance** rapide → opérations ensemblistes.
- **Dictionnaire (`dict`)** : **association clé→valeur**, **ordre d’insertion** → données **étiquetées** et mises à jour rapides.

> 🧪 **Règles rapides :**  
> - Besoin d’**ordre + modif + index** → **liste**  
> - Besoin d’une **séquence figée** → **tuple**  
> - Besoin d’**unicité** et d’**opérations ensemblistes** → **set**  
> - Besoin de **clés nommées** → **dict**

---

## <span style="color:lime">Pièges & bonnes pratiques</span> 🧯

- `{}` crée un **dict vide**, pas un set → utilisez `set()`.  
- Les clés d’un `dict` et les éléments d’un `set` doivent être **hachables** (immutables).  
- Un `tuple` est **immuable**, mais peut référencer des **objets mutables** (qui, eux, peuvent changer).  
- Pour copier :
  - **shallow copy** (superficielle) : `lst.copy()`, `dict.copy()`, `set.copy()`, slicing `lst[:]`.  
  - **deep copy** (profonde, si structures imbriquées) : `import copy; copy.deepcopy(obj)`.  
- Les compréhensions rendent le code **plus lisible** pour des transformations simples ; au-delà, préférez des **boucles nommées**.

---

## <span style="color:lime">Résumé comparatif</span> 🧰

| Collection | Ordonnée | Modifiable | Unicité | Indexable | Accès typique       | Cas d’usage clé                         |
|------------|:--------:|:----------:|:-------:|:---------:|---------------------|-----------------------------------------|
| `list`     |   ✅     |     ✅     |   ❌    |    ✅     | `L[i]`              | Séquences modifiables, parcours, piles  |
| `tuple`    |   ✅     |     ❌     |   ❌    |    ✅     | `t[i]`              | Paquets figés, clés de dict possibles   |
| `set`      |   ❌     |     ✅     |   ✅    |    ❌     | `x in S`            | Unicité, appartenance, ensembles        |
| `dict`     |   ✅*    |     ✅     |  clés ✅|   n/a     | `D[cle]`, `in D`    | Mapping clé→valeur, données structurées |

> *Ordre d’insertion préservé (Python ≥ 3.7).

---

## <span style="color:lime">Exemples rapides “différence avec liste”</span> 🧪

```python
# 1) Unicité : set vs liste
emails = ["a@x", "b@y", "a@x"]
uniques = list(set(emails))    # ['a@x', 'b@y'] (ordre non garanti)

# 2) Accès par clé : dict vs liste d’indices
prix = {"pomme": 2.5, "poire": 3.0}
print(prix["poire"])           # 3.0 (plus expressif que L[1])

# 3) Séquence figée : tuple vs liste
point = (12.0, -3.5)           # garantit que (x,y) ne change pas
# point[0] = 0  → TypeError

# 4) Appartenance rapide : set vs liste
grand_set = set(range(100000))
print(99999 in grand_set)      # rapide
```

---

## <span style="color:lime">Conclusion</span> ✅

Les **listes** sont polyvalentes, mais **chaque collection** a ses **forces** :  
immutabilité des **tuples**, unicité et calculs ensemblistes des **sets**, association **clé→valeur** des **dicts**.  
Choisir la bonne structure rend votre code **plus clair**, **plus sûr** et souvent **plus performant**.
