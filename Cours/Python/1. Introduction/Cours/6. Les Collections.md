# <span style="color:lime">Introduction aux Collections</span> ğŸ“¦

En Python, une **collection** est une structure permettant de stocker **plusieurs Ã©lÃ©ments**.  
Les principales collections intÃ©grÃ©es sont : **liste** (`list`), **tuple** (`tuple`), **ensemble** (`set`) et **dictionnaire** (`dict`).  
Elles diffÃ¨rent par lâ€™**ordre**, la **mutabilitÃ©**, lâ€™**unicitÃ©** des Ã©lÃ©ments, lâ€™**indexation** et les **opÃ©rations** possibles.

> ğŸ” **DiffÃ©rence gÃ©nÃ©rale avec une liste :**  
> La **liste** est **ordonnÃ©e**, **modifiable**, **indexable** et **accepte les doublons**.  
> Les autres collections changent au moins un de ces aspects (immutabilitÃ© pour `tuple`, unicitÃ© non ordonnÃ©e pour `set`, association clÃ©â†’valeur pour `dict`).

---

## <span style="color:lime">Listes</span> ğŸ“‹

Les **listes** modÃ©lisent des **sÃ©quences ordonnÃ©es** dâ€™Ã©lÃ©ments. Elles sont **mutables** (on peut modifier, insÃ©rer, supprimer).

```python
# DÃ©claration
nombres = [1, 2, 3, 4, 5]
noms = ["Alice", "Bob", "Charlie"]
mixte = [1, "Deux", True, 3.14]

# OpÃ©rations usuelles
nombres.append(6)           # ajout en fin
nombres.insert(1, 99)       # insertion Ã  lâ€™indice 1
nombres[2] = 100            # modification
val = nombres.pop()         # retire et retourne le dernier
sous = nombres[1:4]         # slicing
```

**Quand utiliser une liste ?**
- Quand lâ€™**ordre** et lâ€™**indexation** comptent (accÃ©der Ã  lâ€™Ã©lÃ©ment i).
- Quand on a besoin de **modifier** frÃ©quemment le contenu (ajouts, suppressions).

---

## <span style="color:lime">Tuples</span> ğŸ“¦

Un **tuple** est une **sÃ©quence immuable** : une fois crÃ©Ã©, il ne change plus.  
On lâ€™utilise pour des **paquets de valeurs** qui forment un **tout logique** (coordonnÃ©es, date, enregistrement simpleâ€¦).

```python
# DÃ©claration
coordonnees = (10, 20)
couleurs = ("rouge", "vert", "bleu")

# AccÃ¨s (comme une liste)
x = coordonnees[0]
y = coordonnees[1]

# DÃ©pack (unpacking)
r, v, b = couleurs
```

**Par rapport Ã  une liste :**
- **Immuable** â†’ plus sÃ»r et souvent plus lÃ©ger en mÃ©moire.
- Peut servir de **clÃ©** dans un dictionnaire (si ses Ã©lÃ©ments sont eux-mÃªmes hachables).

**Ã€ savoir :**
- `(42,)` tuple Ã  **un seul Ã©lÃ©ment** (la virgule est obligatoire).  
- Un tuple peut contenir des objets **mutables** (ex. liste), mais le **tuple lui-mÃªme** reste immuable.

---

## <span style="color:lime">Ensembles (sets)</span> ğŸ›‘

Un **ensemble** stocke des **Ã©lÃ©ments uniques** (**pas de doublon**) et est **non ordonnÃ©** â†’ **pas dâ€™index**.  
IdÃ©al pour tester lâ€™**appartenance** rapidement et faire des **opÃ©rations ensemblistes** (union, intersectionâ€¦).

```python
# DÃ©claration (attention : {} seul crÃ©e un dict vide !)
lettres = {"a", "b", "c"}
nombres = {1, 2, 3, 4, 5}
vide = set()  # ensemble vide

# UnicitÃ©
S = {1, 2, 2, 3}         # {1, 2, 3}

# OpÃ©rations ensemblistes
A = {1, 2, 3}; B = {3, 4}
print(A | B)             # union â†’ {1, 2, 3, 4}
print(A & B)             # intersection â†’ {3}
print(A - B)             # diffÃ©rence â†’ {1, 2}
print(A ^ B)             # diff. symÃ©trique â†’ {1, 2, 4}

# Test dâ€™appartenance performant
2 in A   # True
```

**Par rapport Ã  une liste :**
- **Uniquement des valeurs uniques** (dÃ©-doublonnage simple).
- **Non ordonnÃ©** et **non indexable**.
- Tests `in` gÃ©nÃ©ralement **plus rapides** (hachage).

**Ã€ savoir :**
- Les Ã©lÃ©ments doivent Ãªtre **hachables** (immutables comme `int`, `str`, `tuple` de hachables).  
- Besoin dâ€™un ensemble **immuable** ? â†’ `frozenset({...})` (hachable, utilisable comme clÃ© de dict).

---

## <span style="color:lime">Dictionnaires</span> ğŸ“š

Un **dictionnaire** associe des **clÃ©s** Ã  des **valeurs** (mapping).  
Depuis Python 3.7+, lâ€™**ordre dâ€™insertion** est **prÃ©servÃ©**.

```python
# DÃ©claration
personne = {"nom": "Alice", "age": 30, "ville": "Paris"}
etudiant = {"matiere": "Math", "note": 18, "annee": 2022}

# AccÃ¨s & mise Ã  jour
print(personne["nom"])             # "Alice"
personne["age"] = 31               # modification
personne["email"] = "a@ex.com"     # ajout
personne.pop("ville")              # suppression

# AccÃ¨s sÃ»r
print(etudiant.get("option", "aucune"))    # Ã©vite KeyError

# Parcours
for k, v in personne.items():
    print(k, "â†’", v)

# Fusion (3.9+)
d1 = {"a": 1}; d2 = {"b": 2}
d3 = d1 | d2                          # {'a': 1, 'b': 2}
```

**Par rapport Ã  une liste :**
- AccÃ¨s par **clÃ©** (nommÃ©e) au lieu dâ€™un **indice** numÃ©rique.
- TrÃ¨s pratique pour des **donnÃ©es structurÃ©es** (Ã©tiquetÃ©es).

**Ã€ savoir :**
- Les **clÃ©s** doivent Ãªtre **hachables** (ex. `str`, `int`, `tuple` de hachables).
- `in` sur un dict teste la prÃ©sence dâ€™une **clÃ©** (pas dâ€™une valeur).

---

## <span style="color:lime">ComprÃ©hensions & constructions rapides</span> âš¡

Les **comprÃ©hensions** existent pour `list`, `set` et `dict` (pas besoin de boucles explicites pour des transformations simples).

```python
# List comprehension
carres = [x*x for x in range(6)]                 # [0, 1, 4, 9, 16, 25]

# Set comprehension (unicitÃ©)
pairs = {x for x in range(10) if x % 2 == 0}     # {0, 2, 4, 6, 8}

# Dict comprehension (clÃ© â†’ valeur)
carres_map = {x: x*x for x in range(5)}          # {0:0, 1:1, 2:4, 3:9, 4:16}
```

---

## <span style="color:lime">Choisir la bonne collection</span> ğŸ§­

- **Liste (`list`)** : suite **ordonnÃ©e**, **modifiable**, avec **doublons** â†’ indexation et parcours sÃ©quentiel.
- **Tuple (`tuple`)** : suite **ordonnÃ©e**, **immuable** â†’ paquet de valeurs **figÃ©** (clÃ© possible en dict).
- **Ensemble (`set`)** : **unicitÃ©**, **non ordonnÃ©**, **test dâ€™appartenance** rapide â†’ opÃ©rations ensemblistes.
- **Dictionnaire (`dict`)** : **association clÃ©â†’valeur**, **ordre dâ€™insertion** â†’ donnÃ©es **Ã©tiquetÃ©es** et mises Ã  jour rapides.

> ğŸ§ª **RÃ¨gles rapides :**  
> - Besoin dâ€™**ordre + modif + index** â†’ **liste**  
> - Besoin dâ€™une **sÃ©quence figÃ©e** â†’ **tuple**  
> - Besoin dâ€™**unicitÃ©** et dâ€™**opÃ©rations ensemblistes** â†’ **set**  
> - Besoin de **clÃ©s nommÃ©es** â†’ **dict**

---

## <span style="color:lime">PiÃ¨ges & bonnes pratiques</span> ğŸ§¯

- `{}` crÃ©e un **dict vide**, pas un set â†’ utilisez `set()`.  
- Les clÃ©s dâ€™un `dict` et les Ã©lÃ©ments dâ€™un `set` doivent Ãªtre **hachables** (immutables).  
- Un `tuple` est **immuable**, mais peut rÃ©fÃ©rencer des **objets mutables** (qui, eux, peuvent changer).  
- Pour copier :
  - **shallow copy** (superficielle) : `lst.copy()`, `dict.copy()`, `set.copy()`, slicing `lst[:]`.  
  - **deep copy** (profonde, si structures imbriquÃ©es) : `import copy; copy.deepcopy(obj)`.  
- Les comprÃ©hensions rendent le code **plus lisible** pour des transformations simples ; au-delÃ , prÃ©fÃ©rez des **boucles nommÃ©es**.

---

## <span style="color:lime">RÃ©sumÃ© comparatif</span> ğŸ§°

| Collection | OrdonnÃ©e | Modifiable | UnicitÃ© | Indexable | AccÃ¨s typique       | Cas dâ€™usage clÃ©                         |
|------------|:--------:|:----------:|:-------:|:---------:|---------------------|-----------------------------------------|
| `list`     |   âœ…     |     âœ…     |   âŒ    |    âœ…     | `L[i]`              | SÃ©quences modifiables, parcours, piles  |
| `tuple`    |   âœ…     |     âŒ     |   âŒ    |    âœ…     | `t[i]`              | Paquets figÃ©s, clÃ©s de dict possibles   |
| `set`      |   âŒ     |     âœ…     |   âœ…    |    âŒ     | `x in S`            | UnicitÃ©, appartenance, ensembles        |
| `dict`     |   âœ…*    |     âœ…     |  clÃ©s âœ…|   n/a     | `D[cle]`, `in D`    | Mapping clÃ©â†’valeur, donnÃ©es structurÃ©es |

> *Ordre dâ€™insertion prÃ©servÃ© (Python â‰¥ 3.7).

---

## <span style="color:lime">Exemples rapides â€œdiffÃ©rence avec listeâ€</span> ğŸ§ª

```python
# 1) UnicitÃ© : set vs liste
emails = ["a@x", "b@y", "a@x"]
uniques = list(set(emails))    # ['a@x', 'b@y'] (ordre non garanti)

# 2) AccÃ¨s par clÃ© : dict vs liste dâ€™indices
prix = {"pomme": 2.5, "poire": 3.0}
print(prix["poire"])           # 3.0 (plus expressif que L[1])

# 3) SÃ©quence figÃ©e : tuple vs liste
point = (12.0, -3.5)           # garantit que (x,y) ne change pas
# point[0] = 0  â†’ TypeError

# 4) Appartenance rapide : set vs liste
grand_set = set(range(100000))
print(99999 in grand_set)      # rapide
```

---

## <span style="color:lime">Conclusion</span> âœ…

Les **listes** sont polyvalentes, mais **chaque collection** a ses **forces** :  
immutabilitÃ© des **tuples**, unicitÃ© et calculs ensemblistes des **sets**, association **clÃ©â†’valeur** des **dicts**.  
Choisir la bonne structure rend votre code **plus clair**, **plus sÃ»r** et souvent **plus performant**.
